<!doctype html>
<html lang="uz">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Mini Runner — Demo</title>
<style>
  :root{--bg:#07121a;--panel:#0f1720;--accent:#00e6ff;--danger:#ff3b6b; color-scheme: dark;}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#02060a,#07121a);color:#e6f7ff}
  #gameWrap{display:flex;gap:18px;padding:18px;align-items:start;justify-content:center;min-height:100vh;box-sizing:border-box}
  .view{width:880px;height:560px;border-radius:16px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,0.6);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08));}
  .ui{width:320px;max-height:560px;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));box-shadow:0 10px 30px rgba(2,6,23,0.6);}
  h1{margin:0 0 8px 0;font-size:20px}
  p.lead{margin:0 0 14px 0;opacity:0.85;font-size:13px}
  .stat{display:flex;justify-content:space-between;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02);margin-bottom:8px}
  .controls{display:flex;gap:8px;margin-top:12px}
  button{background:linear-gradient(90deg,var(--accent),#ff66c4);border:none;padding:10px;border-radius:10px;color:#001;font-weight:700;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit}
  .big{font-size:18px;padding:12px}
  .hint{font-size:13px;opacity:0.85;margin-top:12px}
  .touchPad{display:flex;gap:10px;margin-top:14px}
  .touchBtn{flex:1;padding:14px;border-radius:12px;background:rgba(255,255,255,0.02);text-align:center;user-select:none}
  footer.small{font-size:12px;opacity:0.7;margin-top:16px}
  /* responsive */
  @media (max-width:1000px){
    #gameWrap{flex-direction:column;align-items:center;padding:12px}
    .view,.ui{width:100%;max-width:920px}
    .ui{order:2}
  }
</style>
</head>
<body>
  <div id="gameWrap">
    <div class="view" id="view">
      <canvas id="mainCanvas"></canvas>
    </div>

    <div class="ui">
      <h1>3D Mini Runner</h1>
      <p class="lead">Yo‘l bo‘ylab harakatlaning, to‘siqlardan qoching. Chap/ongga yurish: ← → yoki touch tugmalar.</p>

      <div class="stat"><div>Ball:</div><div id="score">0</div></div>
      <div class="stat"><div>Tezlik:</div><div id="speed">1.0x</div></div>
      <div class="stat"><div>O'yin holati:</div><div id="state">Waiting</div></div>

      <div class="controls">
        <button id="btnStart" class="big">Start</button>
        <button id="btnRestart" class="ghost big">Restart</button>
      </div>

      <div class="hint">Touch: chap/ong tugmalar yordamida harakatlaning. Desktop: ← / → yoki A / D.</div>

      <div class="touchPad">
        <div id="touchLeft" class="touchBtn">⬅️</div>
        <div id="touchRight" class="touchBtn">➡️</div>
      </div>

      <footer class="small">GitHub Pages-ga joylash: faylni `index.html` deb saqlang va repo settings -> Pages -> main branch -> root.</footer>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  // --------- GLOBALS ----------
  const canvas = document.getElementById('mainCanvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x07121a);

  const camera = new THREE.PerspectiveCamera(55, 16/10, 0.1, 1000);
  camera.position.set(0, 6, 10);
  camera.lookAt(0,0,0);

  // Resize handler
  function resize() {
    const wrap = document.getElementById('view');
    const w = wrap.clientWidth, h = wrap.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // Lights
  const hemi = new THREE.HemisphereLight(0xddeeff, 0x0a0a12, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5,10,7);
  dir.castShadow = true;
  dir.shadow.camera.near = 0.5;
  dir.shadow.camera.far = 50;
  scene.add(dir);

  // ROAD
  const road = new THREE.Group();
  scene.add(road);

  const roadWidth = 6;
  const laneCount = 3;
  // road surface
  const groundMat = new THREE.MeshStandardMaterial({color:0x0b1a26, roughness:0.9});
  const groundGeo = new THREE.PlaneGeometry(1000, roadWidth);
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  road.add(ground);

  // lane lines (repeating boxes)
  function makeLaneLines() {
    const mat = new THREE.MeshBasicMaterial({color:0x244b5a});
    const lineMat = new THREE.MeshBasicMaterial({color:0xe6f7ff});
    for(let i=0;i<200;i++){
      const seg = new THREE.Mesh(new THREE.BoxGeometry(4,0.02,0.2), mat);
      seg.position.set(-i*4, 0.01, 0);
      seg.rotation.x = -Math.PI/2;
      road.add(seg);
    }
    // center dashed lines
    for(let i=0;i<300;i++){
      const dash = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.02,0.05), lineMat);
      dash.position.set(-i*2, 0.02, 0);
      dash.rotation.x = -Math.PI/2;
      road.add(dash);
    }
  }
  makeLaneLines();

  // PLAYER CAR (simple box)
  const player = {
    mesh: null,
    lane: 1, // 0 left,1 center,2 right
    lanesX: [-2,0,2],
    targetX: 0,
    alive: true
  };
  const playerMat = new THREE.MeshStandardMaterial({color:0x00e6ff, metalness:0.2, roughness:0.3});
  const carGeo = new THREE.BoxGeometry(1.4,0.6,2);
  const car = new THREE.Mesh(carGeo, playerMat);
  car.castShadow = true;
  car.position.set(0,0.5,4); // a bit towards camera
  scene.add(car);
  player.mesh = car;

  // Obstacles group
  const obstacles = [];
  const obstacleGroup = new THREE.Group(); scene.add(obstacleGroup);

  // Spawning settings
  let spawnTimer = 0;
  let spawnInterval = 1.4; // seconds
  let gameSpeed = 6; // base speed (world moves towards camera)
  let elapsed = 0;
  let score = 0;

  // UI elements
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const stateEl = document.getElementById('state');

  function spawnObstacle() {
    const type = Math.random() < 0.2 ? 'tall' : 'box';
    const lane = Math.floor(Math.random()*3); // 0..2
    const x = player.lanesX[lane];
    const z = -120; // far ahead
    let mesh;
    if(type==='tall'){
      const geo = new THREE.CylinderGeometry(0.5,0.5,2.2,12);
      const mat = new THREE.MeshStandardMaterial({color:0xff6b6b});
      mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x,1.1,z);
    } else {
      const geo = new THREE.BoxGeometry(1.6,1.0,1.6);
      const mat = new THREE.MeshStandardMaterial({color:0xffd166});
      mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x,0.5,z);
    }
    mesh.castShadow = true;
    obstacleGroup.add(mesh);
    obstacles.push({mesh, lane, z});
  }

  // Remove obstacles behind camera
  function cleanupObstacles() {
    for(let i = obstacles.length-1;i>=0;i--){
      if(obstacles[i].mesh.position.z > 30){
        obstacleGroup.remove(obstacles[i].mesh);
        obstacles.splice(i,1);
      }
    }
  }

  // Collision detection (AABB simple)
  function checkCollisions() {
    const pBox = new THREE.Box3().setFromObject(player.mesh);
    for(const obj of obstacles){
      const oBox = new THREE.Box3().setFromObject(obj.mesh);
      if(pBox.intersectsBox(oBox)) return true;
    }
    return false;
  }

  // Controls
  let leftPressed=false, rightPressed=false;
  function moveLeft(){ if(player.lane>0){ player.lane--; player.targetX = player.lanesX[player.lane]; } }
  function moveRight(){ if(player.lane<2){ player.lane++; player.targetX = player.lanesX[player.lane]; } }

  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ moveLeft(); leftPressed=true; }
    if(e.key==='ArrowRight' || e.key==='d' || e.key==='D'){ moveRight(); rightPressed=true; }
    if(e.key===' '){ startGame(); }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ leftPressed=false; }
    if(e.key==='ArrowRight' || e.key==='d' || e.key==='D'){ rightPressed=false; }
  });

  // Touch buttons
  const tLeft = document.getElementById('touchLeft');
  const tRight = document.getElementById('touchRight');
  tLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); moveLeft(); });
  tRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); moveRight(); });

  // Start / Restart buttons
  const btnStart = document.getElementById('btnStart');
  const btnRestart = document.getElementById('btnRestart');
  btnStart.addEventListener('click', ()=> startGame());
  btnRestart.addEventListener('click', ()=> resetGame());

  // GAME STATE
  let running = false;
  function startGame(){
    if(running) return;
    running = true;
    player.alive = true;
    stateEl.innerText = 'Running';
    spawnInterval = 1.4;
    gameSpeed = 6;
  }

  function resetGame(){
    // remove obstacles
    for(const ob of obstacles) obstacleGroup.remove(ob.mesh);
    obstacles.length = 0;
    score = 0; elapsed = 0; spawnTimer = 0;
    player.lane = 1; player.targetX = player.lanesX[1];
    player.mesh.position.set(0,0.5,4);
    running = false; player.alive = true;
    stateEl.innerText = 'Waiting';
    scoreEl.innerText = String(score);
    speedEl.innerText = gameSpeed.toFixed(2) + 'x';
  }

  // Initial reset
  resetGame();
  resize();

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = (now - last)/1000; last = now;
    if(running && player.alive){
      elapsed += dt;
      spawnTimer += dt;

      // gradually increase difficulty
      if(elapsed > 10) gameSpeed = 6 + Math.min(8, (elapsed-10)/6); // up to ~14
      speedEl.innerText = gameSpeed.toFixed(2) + 'x';

      // spawn obstacles
      if(spawnTimer > spawnInterval){
        spawnTimer = 0;
        spawnInterval = 0.9 + Math.random()*1.1 - Math.min(0.7, elapsed/80); // lower with time
        spawnObstacle();
      }

      // move obstacles toward camera by increasing their z
      for(const obj of obstacles){
        obj.mesh.position.z += dt * (gameSpeed*12); // tune multiplier
      }

      // update score by time survived and passed obstacles
      score += dt * 10 * (gameSpeed/6);
      scoreEl.innerText = Math.floor(score);

      // collision?
      if(checkCollisions()){
        player.alive = false;
        running = false;
        stateEl.innerText = 'Crashed! Tap Restart';
        // crash visual
        player.mesh.material.color.set(0xff4d6d);
      }
    }

    // smooth lane movement
    const curX = player.mesh.position.x;
    const dx = player.targetX - curX;
    player.mesh.position.x += dx * Math.min(1, 12*dt); // smoothing factor

    // camera follow slight
    camera.position.x += (player.mesh.position.x - camera.position.x) * 0.06;

    // simple environment: move ground texture by shifting objects (we used long plane so no texture)
    // cleanup
    cleanupObstacles();

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // helpful: pause when tab hidden
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ running=false; stateEl.innerText='Paused'; } });

  // auto-resize on load
  setTimeout(resize,50);
  </script>
</body>
</html>